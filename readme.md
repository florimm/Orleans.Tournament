## Tournament Demo Project

This project is a backend oriented demo with websocket compatibilities that relies heavily in the Actor Model Framework implementation of Microfost: Orleans.
I gave myself the luxury of experimenting with some technologies / practices that might be useful on a real world distributed system:

- DDD
- CQRS
- Projections
- Event sourcing
- Eventual consistency
- Sagas
- Fully async responses communicated via WebSockets.
- Sample authentication implementation (however, if you need to implement auth in a real world app, please don't reinvent the wheel and check existing solutions).
- Simple running Kubernetes environment using Kind on Docker.

This README contains an introduction of the domain being tackled, the technologies used, and a how to run guide.

## Domain

The domain contains two aggregate roots: `Teams` and `Tournaments`.

A `Team` contains a Name, a list of players (strings) and a list of Tournaments IDs on which the team is registered.
A `Tournament` contains a Name, a list of Teams IDs participating and a `Fixture` that is populated when the tournament starts.

For a Tournament to start, the list of teams must have a count of 8. 
When a tournament starts, the teams in the list are shuffled randomly, and the `Fixture` is generated.

A `Fixture` is a value object that contains each of the possible tournament brackets: Quarter, Semi, Finals. Each one of them is represented by another value object named `Phase`.
A `Phase` is a container for a list of `Match` Each one of them contains the `LocalTeamId`, the `AwayTeamId` and the match result when available.

The Quarter phase matches are generated by a random shuffle of the participating teams.
The Semi and the Final phase are not generated randomly but considering the results of previous brackets.

### DDD and Inmutability

In Actor Model Framework, each Actor (such as an aggregate root) contains a state that mutates when applying events. Orleans is not different, and each Grain (Actor) acts the same way. For example:

1. Each TournamentGrain contains a TournamentState.
2. When a TournamentGrain receives a Command, check if the command is valid (business rules).
3. If Command is valid, publish an Event informing what happened and modify the State accordingly.

The TournamentState is not coupled to Orleans framework. So it is just a plain class that exposes methods that act on a certain event. This allows for replayability of events and event sourcing as a whole.
Now, the TournamentState can also contain value objects, such as a Fixture. 

The Fixture is inmutable. This means that the methods exposed by it do not cause side effects and instead returns a new Fixture with the changes reflected. This enables an easier testability and predictibility. 

### CQRS

One of the advantages of using an Actor Model Framework is the innate segregation of commands and queries. The commands are executed against a certain Actor (Grain) and cause side effects, such as the publishing of an Event.
However, the queries do not go against a Grain, instead they go against a read database that gets populated via projections.

![CQRS and projections.](/img/projections.svg)

This is, in fact, eventual consistency. There are some milliseconds between the source of truth (Grain) changes to be reflected in the projections that are queryable. This should not be a problem, but one needs to make sure to enable retry strategies in case the database is down while consuming an event from the stream, etc.

### Sagas

Saga is a pattern for a distributed transaction that impacts more than one aggregate. In this case, lets look at the scenario when a Team wants to join a Tournament.

1. `TournamentGrain` receives the command `AddTeam`.
2. Perform validations:
	- Does the team exist? (note: here you are not supposed to query your read database, but actually send a message to the `TeamGrain`).
	- Does the tournament contain less than 8 teams?
	- Is the tournament not started?
3. Publishes the `TeamAdded` event.

So far, the Tournament is aware of the Team joining, but the `TeamGrain` is not aware of the participation of a Tournament. Enter the `TeamAddedSaga`.

1. `TeamAddedSaga` subscribes to an Orleans Stream looking for `TeamAdded` events.
2. When receives the event, it gets a reference for the `TeamGrain` with the corresponding ID.
3. Publishes command `JoinTournament`.
4. `TeamGrain` receives the command `JoinTournament`.
5. As this is already validated (Tournament exists, has the right amount of teams and did not start) skip validation.
6. Publishes the `TeamJoinedTournament` event.

In this case there is not a rollback strategy nor management as it is not a desired behaviour, but these capabilities can definitely be handled with an "intermediate" Grain that takes care of sending commands in order for each Grain.

### Async communication

### Authentication

### Websockets

### Fallback strategies

### Infrastructure

### How to run it

### Demo video


